---
title: "【TS】冗長な変数宣言を削減し、コードを綺麗に保つ"
emoji: "👌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [typescript,javascript,react]
published: false
---

## はじめに

Reactコンポーネントを実装している際に、テンプレート部分でしか使用することのない一時変数を宣言しなければならないことがあります。
テンプレート部分の記述が短い場合は問題ありませんが、項目数が多いコンポーネント(例えばフォーム)では、変数の宣言箇所と利用箇所が離れてしまい、コードの可読性が下がってしまいます。
私の考えでは、コードの可読性のための説明変数などを除き、中間変数を宣言することは避けるべきだと考えています。

配列の場合は、`map`関数のコールバック内で分割代入を使うことで、オブジェクトから値を取り出すことができます。

```tsx
const items = [{ id: 1, name: "foo" }, { id: 2, name: "bar" }];

const List = () => (
  <ul>
    {items.map(({id,name}) => (
      <li key={id}>{name}</li>
    ))}
  </ul>
);
```

この`id`,`name`変数は`map`関数内のクロージャに閉じ込められているため外から参照できず、安全です。
変数が参照される箇所を限定するということは、それ以外で利用される可能性を排除できるため、コードの可読性が向上します。
同名の変数を別の箇所で再度宣言することもできるため、その都度命名を考える必要もなくなります。
これと同じ手法を、オブジェクトに対しても使用できないでしょうか。

```tsx
const item = { name: "foo", price: 100 };

const Item = () => (
  <div>
    {fromObject(item)(({ name, price }) => (
      <p>{name} : {price}</p>
    ))}
  </div>
)
```

このような、`fromObject`関数を使うことで、オブジェクトの冗長な変数宣言を削減することができます！

## fromObjectとの出会い

まず、オブジェクトを要素数が1つの配列に入れてそのままmapで利用することを考えました。

```tsx
const item = { name: "foo", price: 100 };

const Item = () => (
  <div>
    {[item].map(({ name, price }) => (
      <p>{name} : {price}</p>
    ))}
  </div>
)
```

この方法でも動作はしますが、読み手に「なぜ配列に入れているのか」という疑問が残ります。
また、配列になってしまう都合、ESLintのルールによりkey指定が必要となり手間です。

より良い方法を探して、以下の記事と出会いました。

https://zenn.dev/ynakamura/articles/cfe7047ec345b2

こちらの記事では、JSXにおけるテンプレート内で、複数回に渡るオブジェクトの冗長な変数宣言を削減するための方法としてユーティリティ関数`fromObject`が紹介されています。

私が求めていたのはこの関数でした！

```ts
export function fromObject<T extends Record<string, unknown>>(
  obj: T
): <R>(fn: (obj: T) => R) => R {
  return (fn) => fn(obj)
}
```

2021年の記事であり、掲載から時間が経っているのですが、この記事以外で同様のユーティリティ関数を見たことがありません。

実際に使ってみて少し気になった点が2点ほどあったため、改良を加えてプロジェクトに導入しています。

```ts
export const fromObject = <T>(obj: T) => ({
  map: <R>(callbackFn: (value: T) => R): R => callbackFn(obj),
});
```

- シグネチャを配列の`map`に寄せた。
もとの実装では、戻り値として返ってくる関数を即時実行するような形式となり、あまり見ない書き方でした。
こうすることで、配列の`map`関数と全く同じ使い方ができるようになるため、初めて見る人でも直感的に理解しやすくなります。
私1人しか使わないのであればもとの実装で良かったのですが、他の人に使ってもらうことを考えると、この方が良いと判断しました。
オブジェクトで包むことで若干のオーバーヘッドはあるでしょうが、説明変数のようなもので、必要な処理でしょう。
- 型定義をRecordに狭めず、すべてを受け入れるようにした。
これにより、JSX部以外でリテラルに対して狭いクロージャ内で変換操作を行うような場面でも利用できます。

<!-- ## fromObjectの使い方

`fromObject`関数は、オブジェクトを受け取り、そのオブジェクトを引数に取る関数を返します。
この関数を使うことで、オブジェクトの分割代入を行うことができます。

```tsx
const item = { name: "foo", price: 100 };

const Item = () => (
  <div>
    {fromObject(item)(({ name, price }) => (
      <p>{name} : {price}</p>
    ))}
  </div>
)
```

このように、`fromObject`関数を使うことで、オブジェクトの冗長な変数宣言を削減することができます。 -->


<!-- この記事で紹介されている、`fromObject`ユーティリティ関数が非常に便利です。 -->


<!-- 
2021年の記事であり、掲載から時間が経っているのですがあまり知られておらず、この記事以外で同様のユーティリティ関数を見たことがありません。

上記記事内では、JSXにおけるテンプレート内で、複数回に渡るオブジェクトの冗長な変数宣言を削減するために使う方法として紹介されています。

この関数が嬉しいのはそれだけではありません。 -->

```tsx

const EditForm = () => {
    const [form, field] = 
}
```

<!-- 型定義が付いているため、かなり複雑に見えますが、JavaScriptにトランスパイルしてみると以下の通り。 -->

```js
export function fromObject(obj) {
  return (fn) => fn(obj);
}
```

<!-- 1つ目の関数でオブジェクトを受け取り、2つ目の関数にそのオブジェクトを適用し、その結果を返す関数となっています。

何が嬉しいのかはぜひ元記事を読んでください！ -->
